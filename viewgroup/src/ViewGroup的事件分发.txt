做学问，容不得半点马虎和偷懒!

1、整个ViewGroup的事件分发流程：
    Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View的。
    在ViewGroup中可以通过onInterceptTouchEvent方法对事件传递进行拦截，onInterceptTouchEvent方法返回true代表不允许事件继续向子View传递，返回false代表不对事件进行拦截，默认返回false。
    子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。
2、
    ACTION_DOWN中，ViewGroup捕获到事件，然后判断是否拦截，如果没有拦截，则找到包含当前x,y坐标的子View，赋值给mMotionTarget，然后调用	mMotionTarget.dispatchTouchEvent
        如果被拦截，mMotionTarget = null，执行 ViewGroup 的 super.dispatchTouchEvent(ev)。
    ACTION_MOVE中，ViewGroup捕获到事件，然后判断是否拦截，如果没有拦截，则直接调用mMotionTarget.dispatchTouchEvent(ev)
        如果被拦截，mMotionTarget执行完dispatchTouchEvent后， mMotionTarget = null，所以这个move只会执行一次。
    ACTION_UP中，ViewGroup捕获到事件，然后判断是否拦截，如果没有拦截，则直接调用mMotionTarget.dispatchTouchEvent(ev)
        如果被拦截，mMotionTarget执行完dispatchTouchEvent后， mMotionTarget = null。
    当然了在分发之前都会修改下坐标系统，把当前的x，y分别减去child.left 和 child.top ，然后传给child;
3、关于onInterceptTouchEvent
    默认是不拦截的，即返回false；如果你需要拦截，只要return true就行了，这要该事件就不会往子View传递了。
    如果你在DOWN retrun true ，则DOWN,MOVE,UP子View都不会捕获事件；
    如果你在MOVE return true , 则子View在MOVE和UP都不会捕获事件。
    原因很简单，当onInterceptTouchEvent(ev) return true的时候，会把mMotionTarget 置为null ;
4、如何不被拦截？
    如果ViewGroup的onInterceptTouchEvent(ev) 当ACTION_MOVE时return true ，即拦截了子View的MOVE以及UP事件；
    此时子View希望依然能够响应MOVE和UP时该咋办呢？
    Android给我们提供了一个方法：requestDisallowInterceptTouchEvent(boolean) 用于设置是否允许拦截。
    getParent().requestDisallowInterceptTouchEvent(true);
    当我们把disallowIntercept设置为true时，!disallowIntercept直接为false，于是拦截的方法体就被跳过了~







Android事件分发机制完全解析，带你从源码的角度彻底理解(下) - 郭霖的专栏 - CSDN博客
http://blog.csdn.net/guolin_blog/article/details/9153747
Android ViewGroup事件分发机制 - Hongyang - CSDN博客
http://blog.csdn.net/lmj623565791/article/details/39102591/
    Android 手把手教您自定义ViewGroup（一） - Hongyang - CSDN博客
    http://blog.csdn.net/lmj623565791/article/details/38339817/
    Android 自定义控件打造史上最简单的侧滑菜单 - Hongyang - CSDN博客
    http://blog.csdn.net/lmj623565791/article/details/39185641
Android:30分钟弄明白Touch事件分发机制 - 林J - 博客园
http://www.cnblogs.com/linjzong/p/4191891.html

